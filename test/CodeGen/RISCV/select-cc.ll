; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -disable-block-placement -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32I %s

define i32 @foo(i32 %a, i32 *%b) {
; RV32I-LABEL: foo:
; RV32I:       # %bb.0:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    beq a0, a2, .LBB0_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_2:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bne a0, a2, .LBB0_4
; RV32I-NEXT:  # %bb.3:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_4:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bltu a2, a0, .LBB0_6
; RV32I-NEXT:  # %bb.5:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_6:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bgeu a0, a2, .LBB0_8
; RV32I-NEXT:  # %bb.7:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_8:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bltu a0, a2, .LBB0_10
; RV32I-NEXT:  # %bb.9:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_10:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bgeu a2, a0, .LBB0_12
; RV32I-NEXT:  # %bb.11:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_12:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    blt a2, a0, .LBB0_14
; RV32I-NEXT:  # %bb.13:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_14:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    bge a0, a2, .LBB0_16
; RV32I-NEXT:  # %bb.15:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_16:
; RV32I-NEXT:    lw a2, 0(a1)
; RV32I-NEXT:    blt a0, a2, .LBB0_18
; RV32I-NEXT:  # %bb.17:
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB0_18:
; RV32I-NEXT:    lw a1, 0(a1)
; RV32I-NEXT:    bge a1, a0, .LBB0_20
; RV32I-NEXT:  # %bb.19:
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:  .LBB0_20:
; RV32I-NEXT:    ret
  %val1 = load volatile i32, i32* %b
  %tst1 = icmp eq i32 %a, %val1
  %val2 = select i1 %tst1, i32 %a, i32 %val1

  %val3 = load volatile i32, i32* %b
  %tst2 = icmp ne i32 %val2, %val3
  %val4 = select i1 %tst2, i32 %val2, i32 %val3

  %val5 = load volatile i32, i32* %b
  %tst3 = icmp ugt i32 %val4, %val5
  %val6 = select i1 %tst3, i32 %val4, i32 %val5

  %val7 = load volatile i32, i32* %b
  %tst4 = icmp uge i32 %val6, %val7
  %val8 = select i1 %tst4, i32 %val6, i32 %val7

  %val9 = load volatile i32, i32* %b
  %tst5 = icmp ult i32 %val8, %val9
  %val10 = select i1 %tst5, i32 %val8, i32 %val9

  %val11 = load volatile i32, i32* %b
  %tst6 = icmp ule i32 %val10, %val11
  %val12 = select i1 %tst6, i32 %val10, i32 %val11

  %val13 = load volatile i32, i32* %b
  %tst7 = icmp sgt i32 %val12, %val13
  %val14 = select i1 %tst7, i32 %val12, i32 %val13

  %val15 = load volatile i32, i32* %b
  %tst8 = icmp sge i32 %val14, %val15
  %val16 = select i1 %tst8, i32 %val14, i32 %val15

  %val17 = load volatile i32, i32* %b
  %tst9 = icmp slt i32 %val16, %val17
  %val18 = select i1 %tst9, i32 %val16, i32 %val17

  %val19 = load volatile i32, i32* %b
  %tst10 = icmp sle i32 %val18, %val19
  %val20 = select i1 %tst10, i32 %val18, i32 %val19

  ret i32 %val20
}

; Check that selects of wide values don't introduce unnecessary control flow.

define i64 @cmovcc64(i32 signext %a, i64 %b, i64 %c) nounwind {
; RV32I-LABEL: cmovcc64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    addi a5, zero, 123
; RV32I-NEXT:    beq a0, a5, .LBB1_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:    ret
; RV64I-LABEL: cmovcc64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    addi a3, zero, 123
; RV64I-NEXT:    beq a0, a3, .LBB0_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a1, a2
; RV64I-NEXT:  .LBB0_2: # %entry
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ret
entry:
  %cmp = icmp eq i32 %a, 123
  %cond = select i1 %cmp, i64 %b, i64 %c
  ret i64 %cond
}

define i128 @cmovcc128(i64 signext %a, i128 %b, i128 %c) nounwind {
; RV32I-LABEL: cmovcc128:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    xori a1, a1, 123
; RV32I-NEXT:    or a2, a1, a2
; RV32I-NEXT:    bnez a2, .LBB2_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    addi a6, a3, 4
; RV32I-NEXT:    j .LBB2_3
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    addi a6, a4, 4
; RV32I-NEXT:  .LBB2_3: # %entry
; RV32I-NEXT:    bnez a2, .LBB2_5
; RV32I-NEXT:  # %bb.4:
; RV32I-NEXT:    addi a5, a3, 8
; RV32I-NEXT:    j .LBB2_6
; RV32I-NEXT:  .LBB2_5: # %entry
; RV32I-NEXT:    addi a5, a4, 8
; RV32I-NEXT:  .LBB2_6: # %entry
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    beqz a2, .LBB2_8
; RV32I-NEXT:  # %bb.7: # %entry
; RV32I-NEXT:    mv a1, a4
; RV32I-NEXT:  .LBB2_8: # %entry
; RV32I-NEXT:    bnez a2, .LBB2_10
; RV32I-NEXT:  # %bb.9:
; RV32I-NEXT:    addi a2, a3, 12
; RV32I-NEXT:    j .LBB2_11
; RV32I-NEXT:  .LBB2_10: # %entry
; RV32I-NEXT:    addi a2, a4, 12
; RV32I-NEXT:  .LBB2_11: # %entry
; RV32I-NEXT:    lw a2, 0(a2)
; RV32I-NEXT:    sw a2, 12(a0)
; RV32I-NEXT:    lw a2, 0(a5)
; RV32I-NEXT:    sw a2, 8(a0)
; RV32I-NEXT:    lw a2, 0(a6)
; RV32I-NEXT:    sw a2, 4(a0)
; RV32I-NEXT:    lw a1, 0(a1)
; RV32I-NEXT:    sw a1, 0(a0)
; RV32I-NEXT:    ret
; RV64I-LABEL: cmovcc128:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    addi a5, zero, 123
; RV64I-NEXT:    beq a0, a5, .LBB1_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:    mv a1, a3
; RV64I-NEXT:  .LBB1_2: # %entry
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    mv a1, a2
; RV64I-NEXT:    ret
entry:
  %cmp = icmp eq i64 %a, 123
  %cond = select i1 %cmp, i128 %b, i128 %c
  ret i128 %cond
}

define i64 @cmov64(i1 %a, i64 %b, i64 %c) nounwind {
; RV32I-LABEL: cmov64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a0, a0, 1
; RV32I-NEXT:    bnez a0, .LBB3_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:    ret
; RV64I-LABEL: cmov64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a0, a0, 1
; RV64I-NEXT:    bnez a0, .LBB2_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a1, a2
; RV64I-NEXT:  .LBB2_2: # %entry
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ret
entry:
  %cond = select i1 %a, i64 %b, i64 %c
  ret i64 %cond
}

define i128 @cmov128(i1 %a, i128 %b, i128 %c) nounwind {
; RV32I-LABEL: cmov128:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a4, a1, 1
; RV32I-NEXT:    beqz a4, .LBB4_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    addi a6, a2, 4
; RV32I-NEXT:    j .LBB4_3
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    addi a6, a3, 4
; RV32I-NEXT:  .LBB4_3: # %entry
; RV32I-NEXT:    beqz a4, .LBB4_5
; RV32I-NEXT:  # %bb.4:
; RV32I-NEXT:    addi a5, a2, 8
; RV32I-NEXT:    j .LBB4_6
; RV32I-NEXT:  .LBB4_5: # %entry
; RV32I-NEXT:    addi a5, a3, 8
; RV32I-NEXT:  .LBB4_6: # %entry
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:    bnez a4, .LBB4_8
; RV32I-NEXT:  # %bb.7: # %entry
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:  .LBB4_8: # %entry
; RV32I-NEXT:    beqz a4, .LBB4_10
; RV32I-NEXT:  # %bb.9:
; RV32I-NEXT:    addi a2, a2, 12
; RV32I-NEXT:    j .LBB4_11
; RV32I-NEXT:  .LBB4_10: # %entry
; RV32I-NEXT:    addi a2, a3, 12
; RV32I-NEXT:  .LBB4_11: # %entry
; RV32I-NEXT:    lw a2, 0(a2)
; RV32I-NEXT:    sw a2, 12(a0)
; RV32I-NEXT:    lw a2, 0(a5)
; RV32I-NEXT:    sw a2, 8(a0)
; RV32I-NEXT:    lw a2, 0(a6)
; RV32I-NEXT:    sw a2, 4(a0)
; RV32I-NEXT:    lw a1, 0(a1)
; RV32I-NEXT:    sw a1, 0(a0)
; RV32I-NEXT:    ret
; RV64I-LABEL: cmov128:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a0, .LBB3_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:    mv a1, a3
; RV64I-NEXT:  .LBB3_2: # %entry
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    mv a1, a2
; RV64I-NEXT:    ret
entry:
  %cond = select i1 %a, i128 %b, i128 %c
  ret i128 %cond
}

define float @cmovfloat(i1 %a, float %b, float %c, float %d, float %e) nounwind {
; RV32I-LABEL: cmovfloat:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp)
; RV32I-NEXT:    andi a0, a0, 1
; RV32I-NEXT:    bnez a0, .LBB5_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a3, a4
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:  .LBB5_2: # %entry
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    call __addsf3
; RV32I-NEXT:    lw ra, 12(sp)
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
entry:
  %cond1 = select i1 %a, float %b, float %c
  %cond2 = select i1 %a, float %d, float %e
  %ret = fadd float %cond1, %cond2
  ret float %ret
}

; Check that selects with dependencies on previous ones aren't incorrectly
; optimized.

define i32 @cmovccdep(i32 signext %a, i32 %b, i32 %c, i32 %d) nounwind {
; RV32I-LABEL: cmovccdep:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    addi a4, zero, 123
; RV32I-NEXT:    beq a0, a4, .LBB6_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    beq a0, a4, .LBB6_4
; RV32I-NEXT:  # %bb.3: # %entry
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:  .LBB6_4: # %entry
; RV32I-NEXT:    add a0, a1, a2
; RV32I-NEXT:    ret
entry:
  %cmp = icmp eq i32 %a, 123
  %cond1 = select i1 %cmp, i32 %b, i32 %c
  %cond2 = select i1 %cmp, i32 %cond1, i32 %d
  %ret = add i32 %cond1, %cond2
  ret i32 %ret
}
